@using SisyphusChat.Infrastructure.Entities
@using Microsoft.AspNetCore.Mvc.TagHelpers
@using System.ComponentModel.DataAnnotations
@model ChatPageViewModel

@{
    ViewData["Title"] = "Chats";
}

<head>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.3.0/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>

<div id="errorMessage" class="alert alert-danger d-none" role="alert">
    <div class="d-flex justify-content-between align-items-center">
        <span id="errorMessageText"></span>
    </div>
</div>

<div id="chatPageContainer">
    <div id="sidebar">
        <!-- Search bar with button-->
        <div class="search-container flex items-center gap-2">
            <input type="text" id="searchInput" placeholder="Search for users or groups..." class="search-input" autocomplete="off" />
        </div>
        <a href="@Url.Action("Index", "GroupChat")" id="createGroupChatButton" type="button" class="btn btn-primary w-100">
            <i class="fas fa-comments"></i>
            Create Group Chat
        </a>

        <!-- Combined list for users and group chats -->
        <div id="listContainer" class="scrollable-container">
            <ul id="chatList">
                <!-- Group chats -->
                @foreach (var chat in Model.UserViewModel.AssociatedChats)
                {
                    <li class="user-item flex items-center gap-3" data-type="group">
                        <a href="@Url.Action("OpenGroupChat", "Chat", new { chatId = chat.Id })" class="flex items-center gap-3 w-full">
                            <div class="icon-container">
                                <i class="fas fa-users group-icon"></i>
                            </div>
                            <span class="flex-grow text-blue-600 font-semibold truncate">@chat.Name</span>
                        </a>
                    </li>
                }

                <!-- Users (Private chats) -->
                @foreach (var user in Model.UserViewModel.Users)
                {
                    <li class="user-item flex items-center gap-3" data-type="user">
                        <a href="@Url.Action("CreateOrOpenChat", "Chat", new { recipientUserId = user.Id })" class="flex items-center gap-3 w-full">
                            <div class="icon-container">
                                @if (user.Picture.Length > 0)
                                {
                                    var base64Image = Convert.ToBase64String(@user.Picture);
                                    var imgSrc = $"data:image/jpeg;base64,{base64Image}";
                                    <img class="profile-image" src="@imgSrc" alt="User Avatar" />
                                }
                                else
                                {
                                    <img src="~/images/default_pfp.jpg" alt="Default Profile Picture" class="profile-pic" />
                                }
                            </div>
                            <span class="flex-grow text-blue-600 font-semibold truncate">@user.UserName</span>
                            <span class="status-indicator @(user.IsOnline ? "bg-green-500" : "bg-gray-500")"></span>
                        </a>
                    </li>
                }
            </ul>
        </div>
    </div>

    <div id="chatContainer">
        <div id="chatHeader" class="chat-header @(Model.ChatViewModel.Chat.Type == ChatType.Group ? "" : "no-clickable")">
            <div class="header-content flex items-center gap-3 pb-3">
                @if (Model.ChatViewModel.Chat.Type == ChatType.Group)
{
    <div class="icon-container-large flex items-center">
        @if (Model.ChatViewModel.Chat.ChatUsers.Any(u => u.User.Picture != null))
        {
            <div class="group-images-stack">
                @foreach (var chatUser in Model.ChatViewModel.Chat.ChatUsers.Take(4))
                            {
                                <div class="stacked-image">
                                    @if (chatUser.User.Picture.Length > 0)
                                    {
                                        var base64Image = Convert.ToBase64String(@chatUser.User.Picture);
                                        var imgSrc = $"data:image/jpeg;base64,{base64Image}";
                                        <img class="profile-image" src="@imgSrc" alt="User Avatar" />
                                    }
                                    else
                                    {
                                        <img src="~/images/default_pfp.jpg" alt="Default Profile Picture" />
                                    }
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        <i class="fas fa-users group-icon-large"></i>
                    }
                    <div class="username-status flex flex-col ml-2">
                        <span class="username-text">@Model.ChatViewModel.Chat.Name</span>
                        <span id="groupUsers">
                            @{
                                var membersList = string.Join(", ", Model.ChatViewModel.Chat.ChatUsers.Select(m => m.User.UserName));
                                var displayMembersList = membersList.Length > 90 ? membersList[..87] + "..." : membersList;
                            }
                            @displayMembersList
                        </span>
                    </div>
                    <a href="@Url.Action("Index", "ChatSettings" , new { chatId=Model.ChatViewModel.Chat.Id })" type="button" class="btn btn-primary w-10 gcsettings">Settings</a>
                    <a href="javascript:void(0);" onclick="openChatReportModal()" class="text-red-600 hover:underline">Report</a>
                </div>
            }
                else
                {
                        <!-- Private chat -->
                        <!-- ChatRoom.cshtml -->
                        <div class="icon-container-large flex items-center">
                            <i class="fas fa-user user-icon-large"></i>
                            <div class="username-status flex flex-col ml-2">
                                <span class="username-text">
                                    <a href="@Url.Action("Profile", "Friends", new { username = Model.ChatViewModel.Chat.ChatUsers.First(m => m.UserId != Model.UserViewModel.CurrentUser.Id).User.UserName })" class="text-blue-500 hover:underline">
                                        @Model.ChatViewModel.Chat.ChatUsers.First(m => m.UserId != Model.UserViewModel.CurrentUser.Id).User.UserName
                                    </a>
                                </span>
                                <span class="status-text @(Model.ChatViewModel.Chat.ChatUsers.First(m => m.UserId != Model.UserViewModel.CurrentUser.Id).User.IsOnline ? "text-green-500" : "text-gray-500")">
                                    @(Model.ChatViewModel.Chat.ChatUsers.First(m => m.UserId != Model.UserViewModel.CurrentUser.Id).User.IsOnline ? "Online" : "Offline")
                                </span>
                            </div>
                        </div>
                }
            </div>
        </div>

        <!-- Chat messages container -->
        <div class="chat-messages">
            @foreach (var message in Model.ChatViewModel.Chat.Messages)
            {
                <div class="message @(message.Sender.Id == Model.UserViewModel.CurrentUser.Id ? "sent" : "received")" 
                     data-message-id="@message.Id">
                    <div class="message-header">
                      @if (message.Sender.Picture.Length > 0)
                      {
                          var base64Image = Convert.ToBase64String(@message.Sender.Picture);
                          var imgSrc = $"data:image/jpeg;base64,{base64Image}";
                          <img class="message-profile-pic" src="@imgSrc" alt="User Avatar" />
                      }
                      else
                      {
                          <img src="~/images/default_pfp.jpg" alt="Default Profile Picture" class="message-profile-pic" />
                      }
                    <span class="sender-name">
                        @message.Sender.UserName
                    </span>
                    </div>
                    <p class="message-content">@message.Content</p>
                    <span class="time">
                        @message.TimeCreated.ToString("dd/MM/yyyy', ' HH:mm")
                        @if (message.IsEdited)
                        {
                            <span class="edited-indicator">(edited)</span>
                        }
                    </span>
                    @if (message.Sender.Id == Model.UserViewModel.CurrentUser.Id)
                    {
                        <div class="message-actions">
                            <button class="edit-message-btn" onclick="startEditMessage(this)">
                                <i class="fas fa-edit"></i>
                            </button>

                            <!-- Delete Button -->
                            <button class="delete-message-btn" onclick="deleteMessage('@message.Id')">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    }
                    else
                    {
                        <a href="javascript:void(0);" onclick="openReportModal('@message.Id')" class="text-red-600 hover:underline">Report</a>
                    }

                    @if (message.Sender.Id == Model.UserViewModel.CurrentUser.Id)
                    {
                        <div class="message-status status-@message.Status.ToString().ToLower()">
                            @message.Status.ToString()
                        </div>
                    }
                </div>
            }
        </div>
        <!-- Add edit message form -->
        <div id="editMessageForm" class="edit-message-form d-none">
            <div class="message-input-container">
                <textarea 
                    id="editMessageInput" 
                    maxlength="1000" 
                    rows="1"
                    autocomplete="off"
                    placeholder="Edit message..."
                    class="message-input"
                ></textarea>
                <span class="char-counter">0/1000</span>
            </div>
            <div class="edit-actions">
                <button class="save-btn" onclick="saveEditMessage()">Save</button>
                <button class="cancel-btn" onclick="cancelEditMessage()">Cancel</button>
            </div>
        </div>
        <div class="chat-footer">
            <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off" />
            <button id="sendMessageButton">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
</div>

<!-- Report Popup Modal -->
<div id="reportModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-gray-800 bg-opacity-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h2 class="text-lg font-semibold mb-4">Report Message</h2>

        <form asp-action="ReportMessage" method="post" id="reportForm">
            <input type="hidden" id="chatId" name="chatId" value="@Model.ChatViewModel.Chat.Id"/>
            <input type="hidden" id="messageId" name="messageId"/>

            <div class="mb-4">
                <label for="Type" class="block text-sm font-medium">Report Type:</label>
                <select id="reportType" name="type" class="form-select mt-1 block w-full">
                    @foreach (var reportType in Enum.GetValues(typeof(ReportType)).Cast<ReportType>())
                    {
                        var displayAttribute = reportType.GetType()
                        .GetField(reportType.ToString())
                        .GetCustomAttributes(typeof(DisplayAttribute), false)
                        .FirstOrDefault() as DisplayAttribute;

                        var displayName = displayAttribute != null ? displayAttribute.Name : reportType.ToString();

                        <option value="@reportType">@displayName</option>
                    }
                </select>
            </div>

            <div class="mb-4">
                <label for="Reason" class="block text-sm font-medium">Explanation:</label>
                <textarea id="reason" name="reason" rows="3" class="mt-1 block w-full border border-gray-300 rounded-md p-2" placeholder="Explain your reason for reporting..."></textarea>
            </div>

            <div class="flex justify-end space-x-2">
                <button type="button" onclick="closeReportModal()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">Cancel</button>
                <button type="submit" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Report</button>
            </div>
        </form>
    </div>
</div>

<!-- Chat Report Popup Modal -->
<div id="chatReportModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-gray-800 bg-opacity-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h2 class="text-lg font-semibold mb-4">Report Chat</h2>

        <form asp-action="ReportChat" method="post" id="chatReportForm">
            <input type="hidden" id="reportChatId" name="chatId" value="@Model.ChatViewModel.Chat.Id" />

            <div class="mb-4">
                <label for="reportType" class="block text-sm font-medium">Report Type:</label>
                <select id="reportChatType" name="type" class="form-select mt-1 block w-full">
                    @foreach (var reportType in Enum.GetValues(typeof(ReportType)).Cast<ReportType>())
                    {
                        var displayAttribute = reportType.GetType()
                        .GetField(reportType.ToString())
                        .GetCustomAttributes(typeof(DisplayAttribute), false)
                        .FirstOrDefault() as DisplayAttribute;

                        var displayName = displayAttribute != null ? displayAttribute.Name : reportType.ToString();

                        <option value="@reportType">@displayName</option>
                    }
                </select>
            </div>

            <div class="mb-4">
                <label for="reason" class="block text-sm font-medium">Explanation:</label>
                <textarea id="reportChatReason" name="reason" rows="3" class="mt-1 block w-full border border-gray-300 rounded-md p-2" placeholder="Explain your reason for reporting this chat..."></textarea>
            </div>

            <div class="flex justify-end space-x-2">
                <button type="button" onclick="closeChatReportModal()" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">Cancel</button>
                <button type="submit" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Report</button>
            </div>
        </form>
    </div>
</div>


@section Scripts {
     <script src="~/js/profanityFilter.js"></script>
    <script src="~/js/signalr/dist/browser/signalr.min.js"></script>
    <script>
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/chathub")
            .build();

        const chatId = "@Model.ChatId";
        const currentUser = "@Model.UserViewModel.CurrentUser.UserName";
        const isProfanityEnabled = "@Model.UserViewModel.CurrentUser.IsProfanityEnabled" === "True";

        // To show new messages when chat is opened
        function scrollToBottom() {
            const chatMessages = document.querySelector(".chat-messages");
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        document.addEventListener("DOMContentLoaded", function () {
            scrollToBottom();
        });

        connection.on("ReceiveMessage", async (user, message, chatMembersUserNames, sentAt, messageId, profilePicture) => {
            if (document.baseURI.includes(chatId) && chatMembersUserNames.includes(currentUser)) {
                const messageDiv = document.createElement("div");
                messageDiv.classList.add("message", user === currentUser ? "sent" : "received");
                messageDiv.setAttribute("data-message-id", messageId);

                // Create message header div with flex layout
                const messageHeader = document.createElement("div");
                messageHeader.classList.add("message-header");
                messageHeader.style.display = "flex";
                messageHeader.style.alignItems = "center";
                messageHeader.style.gap = "8px";

                // Create and set up profile picture
                const profileImg = document.createElement("img");
                profileImg.classList.add("message-profile-pic");
                profileImg.src = profilePicture ? `data:image/jpeg;base64,${profilePicture}` : "/images/default_pfp.jpg";
                profileImg.alt = user === currentUser ? "Your Avatar" : "User Avatar";

                // Create sender name span
                const senderNameSpan = document.createElement("span");
                senderNameSpan.classList.add("sender-name");
                senderNameSpan.textContent = user;

                // Append elements in correct order
                messageHeader.appendChild(profileImg);
                messageHeader.appendChild(senderNameSpan);
                messageDiv.appendChild(messageHeader);

                const messageContent = document.createElement("p");
                messageContent.classList.add("message-content");
                
                // Only filter if user has enabled profanity filter
                if (isProfanityEnabled) {
                    messageContent.textContent = ProfanityFilter.filterMessage(message);
                } else {
                    messageContent.textContent = message;
                }
                
                messageDiv.appendChild(messageContent);

                const timestampSpan = document.createElement("span");
                timestampSpan.classList.add("time");
                timestampSpan.textContent = new Date(sentAt).toLocaleString([], { dateStyle: 'short', timeStyle: 'short' });
                messageDiv.appendChild(timestampSpan);

                // Add edit and delete buttons for own messages
                if (user === currentUser) {
                    const messageActions = document.createElement("div");
                    messageActions.classList.add("message-actions");

                    // Edit button
                    const editButton = document.createElement("button");
                    editButton.classList.add("edit-message-btn");
                    editButton.onclick = function () { startEditMessage(this); };
                    const editIcon = document.createElement("i");
                    editIcon.classList.add("fas", "fa-edit");
                    editButton.appendChild(editIcon);

                    // Delete button
                    const deleteButton = document.createElement("button");
                    deleteButton.classList.add("delete-message-btn");
                    deleteButton.onclick = function () { deleteMessage(messageId); };
                    const deleteIcon = document.createElement("i");
                    deleteIcon.classList.add("fas", "fa-trash");
                    deleteButton.appendChild(deleteIcon);

                    messageActions.appendChild(editButton);
                    messageActions.appendChild(deleteButton);
                    messageDiv.appendChild(messageActions);
                } else {
                    const reportLink = document.createElement("a");
                    reportLink.href = "javascript:void(0);";
                    reportLink.onclick = function () { openReportModal(messageId); };
                    reportLink.classList.add("text-red-600", "hover:underline");
                    reportLink.textContent = "Report";
                    messageDiv.appendChild(reportLink);
                }

                document.querySelector(".chat-messages").appendChild(messageDiv);
                scrollToBottom();

                // Add status indicator for sent messages
                if (user === currentUser) {
                    const statusDiv = document.createElement("div");
                    statusDiv.classList.add("message-status", "status-sent");
                    statusDiv.textContent = "Sent";
                    messageDiv.appendChild(statusDiv);
                }

                // If this is a received message, mark it as delivered
                if (user !== currentUser) {
                    connection.invoke("MarkMessageAsDelivered", messageId)
                        .catch(err => console.error("Error marking message as delivered:", err));
                }
            } else {
                const errorContainer = document.getElementById("errorMessage");
                const errorMessageText = document.getElementById("errorMessageText");
                errorMessageText.textContent = "You are no longer a member of this chat.";
                errorContainer.classList.remove("d-none");
                document.getElementById("messageInput").disabled = true;
                document.getElementById("sendMessageButton").disabled = true;
            }
        });


        async function startConnection() {
            try {
                await connection.start();
                console.log("SignalR Connected.");
                await connection.invoke("JoinChat", chatId);
                
                // Setup message observer after connection is established
                setupMessageObserver();
            } catch (err) {
                console.error("SignalR Connection Error: ", err);
                setTimeout(() => startConnection(), 5000);
            }
        }

        startConnection();

        connection.on("ReceiveError", (errorMessage) => {
            const errorContainer = document.getElementById("errorMessage");
            const errorMessageText = document.getElementById("errorMessageText");

            errorMessageText.textContent = errorMessage;

            errorContainer.classList.remove("d-none");

            document.getElementById("messageInput").disabled = true;
            document.getElementById("sendMessageButton").disabled = true;
        });

        // Send message when the send button is clicked
        document.getElementById("sendMessageButton").addEventListener("click", () => {
            const message = document.getElementById("messageInput").value;
            const errorContainer = document.getElementById("errorMessage");
            const errorMessageText = document.getElementById("errorMessageText");

            if (message.trim() === "") {
                return;
            }

            if (message.length > 1000) {
                errorMessageText.textContent = "Message cannot exceed 1000 characters.";
                errorContainer.classList.remove("d-none");
                return;
            }

            errorContainer.classList.add("d-none");

            // Check if the connection is in the connected state before sending
            if (connection.state === signalR.HubConnectionState.Connected) {
                connection.invoke("SendMessage", currentUser, message, chatId)
                    .catch(err => console.error("SendMessage Error: ", err));
                document.getElementById("messageInput").value = "";
            } else {
                console.warn("Cannot send message. SignalR connection is not established.");
            }
        });

        // Send message when Enter key is pressed in the input field
        document.getElementById("messageInput").addEventListener("keydown", function (event) {
            if (event.keyCode === 13 && !event.shiftKey) {  // Enter key without Shift
                event.preventDefault(); // Prevent the default behavior of adding a new line

                const message = document.getElementById("messageInput").value;
                const errorContainer = document.getElementById("errorMessage");
                const errorMessageText = document.getElementById("errorMessageText");

                if (message.trim() === "") {
                    return;
                }

                if (message.length > 1000) {
                    errorMessageText.textContent = "Message cannot exceed 1000 characters.";
                    errorContainer.classList.remove("d-none");
                    return;
                }

                errorContainer.classList.add("d-none");

                // Check if the connection is in the connected state before sending
                if (connection.state === signalR.HubConnectionState.Connected) {
                    connection.invoke("SendMessage", currentUser, message, chatId)
                        .catch(err => console.error("SendMessage Error: ", err));
                    document.getElementById("messageInput").value = ""; // Clear the input field
                } else {
                    console.warn("Cannot send message. SignalR connection is not established.");
                }
            }
        });

        // Filter chat list by search input
        document.getElementById("searchInput").addEventListener("input", function () {
            const searchTerm = this.value.toLowerCase();
            const items = document.querySelectorAll("#chatList .user-item");

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(searchTerm)) {
                    item.style.display = "";
                } else {
                    item.style.display = "none";
                }
            });
        });

        // Add these functions after your existing SignalR setup
        let currentEditMessageId = null;
        let originalMessage = null;

        function startEditMessage(button) {
            const messageDiv = button.closest('.message');
            if (!messageDiv) return;
            
            const messageId = messageDiv.getAttribute("data-message-id");
            if (!messageId) return;

            // Get the original message from the server
            connection.invoke("GetOriginalMessage", messageId)
                .then(originalContent => {
                    currentEditMessageId = messageId;
                    originalMessage = originalContent;

                    const editForm = document.getElementById('editMessageForm');
                    const editInput = document.getElementById('editMessageInput');
                    const counter = editForm.querySelector('.char-counter');
                    
                    // Set the original content and update counter
                    editInput.value = originalContent;
                    const currentLength = originalContent.length;
                    counter.textContent = `${currentLength}/1000`;
                    
                    // Apply appropriate counter styling based on length
                    counter.classList.remove("near-limit", "over-limit");
                    if (currentLength > 900) {
                        counter.classList.add("near-limit");
                    }
                    if (currentLength > 1000) {
                        counter.classList.add("over-limit");
                    }

                    // Auto-resize the textarea for initial content
                    autoResizeTextarea(editInput);
                    
                    editForm.classList.remove('d-none');
                    const messageContent = messageDiv.querySelector('.message-content');
                    messageContent.style.display = 'none';
                    editForm.setAttribute('data-editing-message-id', messageId);
                    editInput.focus();
                })
                .catch(err => console.error("Error getting original message:", err));
        }

        // Add input event listener for edit textarea
        document.getElementById('editMessageInput').addEventListener('input', function() {
            autoResizeTextarea(this);
            
            // Existing character counter code
            const charCount = this.value.length;
            const counter = this.parentElement.querySelector('.char-counter');
            const MAX_CHARS = 1000;
            const WARN_THRESHOLD = 900;
            
            counter.textContent = `${charCount}/${MAX_CHARS}`;
            counter.classList.remove("near-limit", "over-limit");
            if (charCount > WARN_THRESHOLD) {
                counter.classList.add("near-limit");
            }
            if (charCount > MAX_CHARS) {
                counter.classList.add("over-limit");
            }
        });

        function saveEditMessage() {
            const editForm = document.getElementById('editMessageForm');
            const editInput = document.getElementById('editMessageInput');
            const messageId = editForm.getAttribute('data-editing-message-id');
            const newContent = editInput.value.trim();
            
            if (!messageId) {
                console.error("No message ID found for editing");
                return;
            }
            
            if (newContent === '' || newContent === originalMessage) {
                cancelEditMessage();
                return;
            }

            connection.invoke("EditMessage", messageId, newContent, chatId)
                .then(() => {
                    cancelEditMessage();
                })
                .catch(err => {
                    console.error("Error editing message:", err);
                    const errorContainer = document.getElementById("errorMessage");
                    const errorMessageText = document.getElementById("errorMessageText");
                    errorMessageText.textContent = "Failed to edit message";
                    errorContainer.classList.remove("d-none");
                    
                    setTimeout(() => {
                        errorContainer.classList.add("d-none");
                    }, 5000);
                });
        }

        function cancelEditMessage() {
            const editForm = document.getElementById('editMessageForm');
            const messageDiv = document.querySelector(`[data-message-id="${currentEditMessageId}"]`);
            const messageContent = messageDiv.querySelector('.message-content');
            
            editForm.classList.add('d-none');
            messageContent.style.display = 'block';
            currentEditMessageId = null;
            originalMessage = null;
        }

        function deleteMessage(messageId) {
            if (confirm("Are you sure you want to delete this message?")) {
                connection.invoke("DeleteMessage", messageId)
                    .catch(err => console.error("Failed to delete message:", err));
            }
        }


        
        connection.on("MessageEdited", (messageId, newContent, lastUpdated, isEdited, senderId) => {
            const messageDiv = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                const messageContent = messageDiv.querySelector('.message-content');
                const timeSpan = messageDiv.querySelector('.time');
                
                // Show uncensored version to message author, censored to others
                if (senderId === currentUser) {
                    messageContent.textContent = newContent;
                } else if (isProfanityEnabled) {
                    messageContent.textContent = ProfanityFilter.filterMessage(newContent);
                } else {
                    messageContent.textContent = newContent;
                }
                
                // Format time to show only hours and minutes
                const date = new Date(lastUpdated);
                const timeString = date.toLocaleTimeString([], { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: true 
                });
                
                timeSpan.innerHTML = `${timeString} ${isEdited ? '(edited)' : ''}`;
            }
        });

      
        connection.on("UserDeleted", function (userId, newUsername) {
            // Update usernames in chat list
            const userItems = document.querySelectorAll('.user-item');
            userItems.forEach(item => {
                const usernameSpan = item.querySelector('.text-blue-600');
                if (usernameSpan && usernameSpan.textContent === newUsername) {
                    usernameSpan.textContent = newUsername;
                }
            });

            // Update usernames in messages
            const senderNames = document.querySelectorAll('.sender-name');
            senderNames.forEach(span => {
                if (span.textContent === newUsername) {
                    span.textContent = newUsername;
                }
            });

            // Update group chat members list if present
            const groupUsers = document.getElementById('groupUsers');
            if (groupUsers) {
                const members = groupUsers.textContent.split(', ');
                const updatedMembers = members.map(member => 
                    member === newUsername ? newUsername : member
                );
                groupUsers.textContent = updatedMembers.join(', ');
            }
        });

        connection.on("MessageDeleted", (messageId) => {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.remove();
            }
        });


        // Open and close the modal
        function openReportModal(messageId) {
            document.getElementById('reportModal').style.display = 'flex';
            document.getElementById("messageId").value = messageId;
        }

        function closeReportModal() {
            document.getElementById('reportModal').style.display = 'none';
        }

        // Open and close the chat report modal
        function openChatReportModal() {
            document.getElementById('chatReportModal').style.display = 'flex';
        }

        function closeChatReportModal() {
            document.getElementById('chatReportModal').style.display = 'none';
        }

        function sendMessage() {
            const messageInput = document.getElementById("messageInput");
            const message = messageInput.value.trim();
            const MAX_CHARS = 1000;

            // Clear any existing error states
            messageInput.classList.remove("input-error");
            
            if (message.length > MAX_CHARS) {
                showCharacterLimitError(message.length, MAX_CHARS);
                messageInput.classList.add("input-error");
                return;
            }

            // Rest of your existing send message code...
        }

        function showCharacterLimitError(currentLength, maxLength) {
            const errorContainer = document.getElementById("errorMessage");
            const errorMessageText = document.getElementById("errorMessageText");
            
            errorMessageText.innerHTML = `
                <div class="d-flex align-items-center gap-2">
                    <i class="fas fa-exclamation-circle text-danger"></i>
                    <span>Message is too long (${currentLength}/${maxLength} characters)</span>
                </div>`;
            
            errorContainer.classList.remove("d-none");
            
            // Auto-hide the error after 5 seconds
            setTimeout(() => {
                errorContainer.classList.add("d-none");
            }, 5000);
        }

        // Add this to provide real-time feedback
        function setupMessageInput() {
            const messageInput = document.getElementById("messageInput");
            const MAX_CHARS = 1000;
            const WARN_THRESHOLD = 900; // Show warning color at 90% capacity
            
            // Wrap input in container if not already wrapped
            if (!messageInput.parentElement.classList.contains('message-input-container')) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('message-input-container');
                messageInput.parentNode.insertBefore(wrapper, messageInput);
                wrapper.appendChild(messageInput);
            }
            
            // Create counter if it doesn't exist
            if (!document.getElementById("charCounter")) {
                const counter = document.createElement("div");
                counter.id = "charCounter";
                counter.classList.add("char-counter");
                messageInput.parentElement.appendChild(counter);
            }
            
            messageInput.addEventListener("input", function() {
                const charCount = this.value.length;
                const counter = document.getElementById("charCounter");
                
                // Update counter text
                counter.textContent = `${charCount}/${MAX_CHARS}`;
                
                // Reset classes
                counter.classList.remove("near-limit", "over-limit");
                messageInput.classList.remove("input-error");
                
                // Apply appropriate styling based on character count
                if (charCount > MAX_CHARS) {
                    counter.classList.add("over-limit");
                    messageInput.classList.add("input-error");
                } else if (charCount > WARN_THRESHOLD) {
                    counter.classList.add("near-limit");
                }
                
                // Show/hide counter based on content
                if (charCount > 0) {
                    counter.style.opacity = "1";
                }
            });
            
            // Hide counter when input is empty and not focused
            messageInput.addEventListener("blur", function() {
                const counter = document.getElementById("charCounter");
                if (this.value.length === 0) {
                    counter.style.opacity = "0";
                }
            });
        }

        // Call this when the page loads
        document.addEventListener("DOMContentLoaded", setupMessageInput);

        connection.on("MessageStatusUpdated", (messageId, status) => {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const statusIndicator = messageElement.querySelector('.message-status');
                if (statusIndicator) {
                    statusIndicator.textContent = status;
                    statusIndicator.className = `message-status status-${status.toLowerCase()}`;
                }
            }
        });

        // Modify the setupMessageObserver function to check connection state
        function setupMessageObserver() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const messageElement = entry.target;
                        const messageId = messageElement.dataset.messageId;
                        if (messageId && messageElement.classList.contains('received')) {
                            // Check connection state before invoking
                            if (connection.state === signalR.HubConnectionState.Connected) {
                                connection.invoke("MarkMessageAsSeen", messageId)
                                    .catch(err => console.error("Error marking message as seen:", err));
                            }
                        }
                    }
                });
            }, { threshold: 1.0 });

            // Observe all received messages
            document.querySelectorAll('.message.received').forEach(message => {
                observer.observe(message);
            });
        }

        // Move the observer setup to after connection is established
        async function startConnection() {
            try {
                await connection.start();
                console.log("SignalR Connected.");
                await connection.invoke("JoinChat", chatId);
                
                // Setup message observer after connection is established
                setupMessageObserver();
            } catch (err) {
                console.error("SignalR Connection Error: ", err);
                setTimeout(() => startConnection(), 5000);
            }
        }

        // Remove the DOMContentLoaded event listener for setupMessageObserver
        // and instead call it after connection is established

        // Also add reconnection handling
        connection.onreconnected(async () => {
            console.log("SignalR Reconnected.");
            await connection.invoke("JoinChat", chatId);
            setupMessageObserver(); // Re-setup observer after reconnection
        });

        connection.onreconnecting(() => {
            console.log("SignalR Reconnecting...");
        });

        connection.onclose(() => {
            console.log("SignalR Connection Closed.");
        });

        // Add this to filter existing messages when page loads
        document.addEventListener("DOMContentLoaded", async () => {
            if (isProfanityEnabled) {
                const messageContents = document.querySelectorAll('.message-content');
                messageContents.forEach(content => {
                    const originalText = content.textContent;
                    content.textContent = ProfanityFilter.filterMessage(originalText);
                });
            }
            scrollToBottom();
            setupMessageInput();
        });

        // Add this auto-resize function
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 300) + 'px';
        }

        // Add event listener for the textarea
        document.getElementById('editMessageInput').addEventListener('input', function() {
            autoResizeTextarea(this);
            
            // Existing character counter code
            const charCount = this.value.length;
            const counter = this.parentElement.querySelector('.char-counter');
            const MAX_CHARS = 1000;
            const WARN_THRESHOLD = 900;
            
            counter.textContent = `${charCount}/${MAX_CHARS}`;
            counter.classList.remove("near-limit", "over-limit");
            if (charCount > WARN_THRESHOLD) {
                counter.classList.add("near-limit");
            }
            if (charCount > MAX_CHARS) {
                counter.classList.add("over-limit");
            }
        });
    </script>
}


<style scoped>
html, body {
    margin: 0;
    padding: 0;
}

.container {
    margin: 0;
    padding: 0;
    width: 100%;
}

.icon-container-large {
    display: flex;
    align-items: center; /* Aligns items vertically in the center */
}

main[b-fefn0adsrq] {
    margin: 0;
}

.sender-name {
    font-weight: bold;
}

.gcsettings {
    margin-left: auto;
    margin-right: 1%;
}

/* Message actions */
.message-actions {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  opacity: 0;
  transition: opacity 0.2s ease;
  display: flex;
  gap: 0.5rem;
}

.message:hover .message-actions {
  opacity: 1;
}

.edit-message-btn {
  background: rgba(255, 255, 255, 0.1);
  border: none;
  padding: 0.4rem;
  border-radius: 8px;
  cursor: pointer;
  color: white;
  transition: all 0.2s ease;
}

.edit-message-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.05);
}

/* Edit message form */
.edit-message-form {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 1rem;
  margin: 0.5rem 0;
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(8px);
}

.edit-message-form input {
  width: 100%;
  padding: 0.75rem 1rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.05);
  color: var(--text-color);
  margin-bottom: 0.75rem;
}

.edit-actions {
  display: flex;
  gap: 0.75rem;
}

.edit-actions button {
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s ease;
}

.edit-actions button:first-child {
  background: linear-gradient(135deg, var(--accent-color) 0%, var(--accent-color-dark) 100%);
  color: white;
}

.edit-actions button:last-child {
  background: rgba(220, 53, 69, 0.1);
  color: #dc3545;
}

.edit-actions button:hover {
  transform: translateY(-2px);
}
.gcsettings {
    margin-left: auto;
    margin-right: 1%;
}

/* Modal container styles */
#reportModal,
#chatReportModal {
    backdrop-filter: blur(12px);
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    z-index: 1000;
}

#reportModal .bg-white,
#chatReportModal .bg-white {
    background: rgba(255, 255, 255, 0.07) !important;
    border: 1px solid rgba(var(--text-color-rgb), 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    border-radius: 24px;
    max-width: 500px;
    width: 90%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 2rem;
}

#reportModal h2,
#chatReportModal h2 {
    color: var(--text-color);
    font-size: 1.75rem;
    margin-bottom: 2rem;
    background: linear-gradient(135deg, var(--text-color) 0%, rgba(var(--text-color-rgb), 0.7) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-align: center;
}

#reportModal select,
#chatReportModal select {
    background: var(--bg-color);
    border: 1px solid rgba(var(--text-color-rgb), 0.1);
    color: var(--text-color);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
    border-radius: 16px;
    padding: 1rem;
    width: 100%;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 1rem center;
    background-size: 1.5em;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 0.01em;
}

#reportModal select option,
#chatReportModal select option {
    background: var(--bg-color);
    color: var(--text-color);
    padding: 1rem;
    font-size: 1rem;
    font-weight: 500;
}

#reportModal textarea,
#chatReportModal textarea {
    background: var(--bg-color);
    border: 1px solid rgba(var(--text-color-rgb), 0.1);
    color: var(--text-color);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
    border-radius: 16px;
    padding: 1rem;
    min-height: 120px;
    width: 100%;
    resize: vertical;
    margin: 1rem 0;
}

#reportModal select:focus,
#chatReportModal select:focus,
#reportModal textarea:focus,
#chatReportModal textarea:focus {
    border-color: var(--accent-color);
    box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb), 0.2);
    outline: none;
}

#reportModal label,
#chatReportModal label {
    color: var(--text-color);
    opacity: 0.9;
    font-size: 1rem;
    font-weight: 500;
    margin-bottom: 0.75rem;
    display: block;
}

/* Modal Buttons Container */
#reportModal .flex,
#chatReportModal .flex {
    display: flex;
    gap: 1rem;
    margin-top: 2rem;
    justify-content: flex-end;
}

/* Modal Buttons */
#reportModal button,
#chatReportModal button {
    padding: 0.875rem 1.75rem;
    border-radius: 16px;
    font-weight: 600;
    font-size: 1rem;
    transition: all 0.3s ease;
    min-width: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

#reportModal button[type="submit"],
#chatReportModal button[type="submit"] {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    border: none;
    box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
}

#reportModal button[type="submit"]:hover,
#chatReportModal button[type="submit"]:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
}

#reportModal button[type="button"],
#chatReportModal button[type="button"] {
    background: rgba(var(--text-color-rgb), 0.1);
    border: 1px solid rgba(var(--text-color-rgb), 0.1);
    color: var(--text-color);
}

#reportModal button[type="button"]:hover,
#chatReportModal button[type="button"]:hover {
    background: rgba(var(--text-color-rgb), 0.15);
    transform: translateY(-2px);
}

/* Overlay Background */
#reportModal::before,
#chatReportModal::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
    z-index: -1;
}

/* Animation */
@@keyframes modalFadeIn {
    from {
        opacity: 0;
        transform: translate(-50%, -48%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

#reportModal .bg-white,
#chatReportModal .bg-white {
    animation: modalFadeIn 0.3s ease-out;
}

/* Add to your existing styles */
.message-status {
    font-size: 0.75rem;
    margin-top: 4px;
    text-align: right;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 4px;
    padding: 2px 6px;
    border-radius: 12px;
    width: fit-content;
    margin-left: auto;
    transition: all 0.2s ease;
}

/* Status colors and icons */
.status-sent {
    color: #a1a1aa;
}

.status-delivered {
    color: #60a5fa;
}

.status-read {
    color: #22c55e;
}

.message-status::before {
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    font-size: 0.7rem;
}

.status-sent::before {
    content: "\f00c";  /* single check */
}

.status-delivered::before {
    content: "\f560";  /* double check */
}

.status-read::before {
    content: "\f560";  /* double check */
    background: linear-gradient(135deg, #22c55e, #16a34a);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

/* Hover effects */
.message:hover .message-status {
    opacity: 1;
    transform: translateY(-1px);
}

/* Status transitions */
.message-status {
    opacity: 0.7;
    transform: translateY(0);
    transition: all 0.2s ease;
}

/* Add these new styles */
.delete-message-btn {
  background: rgba(220, 53, 69, 0.1);
  border: none;
  padding: 0.4rem;
  border-radius: 8px;
  cursor: pointer;
  color: #dc3545;
  transition: all 0.2s ease;
}

.delete-message-btn:hover {
  background: rgba(220, 53, 69, 0.2);
  transform: scale(1.05);
}

.delete-message-btn i {
  transition: transform 0.2s ease;
}

.delete-message-btn:hover i {
  transform: rotate(12deg);
}

.edit-message-form {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 8px;
    margin: 8px 0;
}

.edit-input-container {
    position: relative;
    margin-bottom: 8px;
}

.edit-input-container textarea {
    width: 100%;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: #fff;
    padding: 12px;
    padding-right: 70px; /* Space for counter */
    resize: none;
    overflow-y: auto;
    min-height: 44px;
    max-height: 150px;
    line-height: 1.5;
    font-size: 14px;
}

.edit-input-container textarea:focus {
    outline: none;
    border-color: rgba(255, 255, 255, 0.2);
}

.char-counter {
    position: absolute;
    right: 12px;
    bottom: 12px;
    color: rgba(255, 255, 255, 0.5);
    font-size: 12px;
}

.edit-actions {
    display: flex;
    gap: 8px;
}

.edit-actions button {
    padding: 6px 16px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.save-btn {
    background: #7c5cff;
    color: white;
}

.save-btn:hover {
    background: #6a4eff;
}

.cancel-btn {
    background: rgba(255, 255, 255, 0.1);
    color: #fff;
}

.cancel-btn:hover {
    background: rgba(255, 255, 255, 0.15);
}

.message-input-container textarea {
    resize: none;
    border: none;
    background: transparent;
    overflow-y: auto;
    min-height: 60px;
    max-height: 300px;
    width: 100%;
    padding: 12px;
    line-height: 1.5;
}

/* Ensure the container can handle the larger textarea */
.message-input-container {
    min-height: 60px;
    max-height: 300px;
    width: 100%;
    position: relative;
}
</style>